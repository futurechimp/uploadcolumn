<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>File: README</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href=".././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



  <div id="fileHeader">
    <h1>README</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>README
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Tue Nov 07 23:38:12 CET 2006</td>
    </tr>
    </table>
  </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">

    <div id="description">
      <h1>Upload_column</h1>
<p>
Upload_column is a plugin for the Ruby on Rails framework that enables easy
uploading of files, especially images.
</p>
<p>
Suppose you have a list of users, and you would like to associate a picture
to each of them. You could upload the image to a database, or you could use
upload_column for simple storage to the file system.
</p>
<p>
Let&#8217;s create our database first, generate a migration (if
you&#8217;re not using migrations yet you are missing out!) and add
</p>
<pre>
    create_table &quot;users&quot; do |t|
      t.column &quot;name&quot;, :string
      t.column &quot;picture&quot;, :string
    end
</pre>
<p>
Now generate a scaffold for your user class
</p>
<p>
Create your model class and add the upload_column method call:
</p>
<pre>
    class User &lt; ActiveRecord::Base
      upload_column :picture
    end
</pre>
<p>
Have a look at <a
href="../classes/UploadColumn/ClassMethods.html#M000001">UploadColumn::ClassMethods.upload_column</a>
to find out more about specialized options. Note that the picture column in
the database will not store the actual picture, it will only store the
filename.
</p>
<p>
Now just open up your _form.rhtml partial, and edit it so it looks like the
following:
</p>
<pre>
    &lt;p&gt;&lt;label for=&quot;user_picture&quot;&gt;Picture&lt;/label&gt;&lt;br/&gt;
    &lt;%= upload_column_field 'user', 'picture'  %&gt;&lt;/p&gt;
</pre>
<p>
Here we&#8217;re making a call to <a
href="../classes/UploadColumnHelper.html#M000024">UploadColumnHelper.upload_column_field</a>,
this will create an input field of the file type.
</p>
<p>
We&#8216;ll need to set the form to multipart, so that the picture will
actually be sent as well. In new.rhtml change the <tt>start_form_tag</tt>
declaration to something like:
</p>
<pre>
    &lt;%= start_form_tag( { :action =&gt; 'create' }, { :multipart =&gt; true } ) %&gt;
</pre>
<p>
And that&#8217;s it! Your uploads are up and running (hopefully) and you
should now be able to add pictures to your users. The madness doesn&#8217;t
stop there of course!
</p>
<h2>Storage Path</h2>
<p>
You won&#8217;t always want to store the pictures in the directory that
upload_column selects for you, but that&#8217;s not a problem, because
changing that directory is trivial. You can pass a <tt>:store_dir</tt> key
to the upload_column declaration, this will override the default mechanism
and always use that directory as the basis.
</p>
<pre>
    upload_column :picture, :store_dir =&gt; &quot;public/images/user_pictures&quot;
</pre>
<p>
might be sensible in our case. By default upload_column will create a
directory labeled after the associated object&#8217;s id and save the image
to that directory. So if our user has id 5, then the image would actually
be saved to
</p>
<pre>
    public/images/user_pictures/5
</pre>
<p>
This can easily be turned off by specifying
</p>
<pre>
    upload_column :picture, :store_dir =&gt; &quot;public/images/user_pictures&quot;, :store_dir_append_id =&gt; false
</pre>
<p>
If you need more refined control over the storage path (maybe you need to
store it by the id of an association?) then you can use a callback method.
In our case the method would be called <tt>picture_store_dir</tt>. Just
append <tt>_store_dir</tt> to your upload_column field.
</p>
<pre>
    def picture_store_dir
      &quot;public/images/#{self.category.name}&quot;
    end
</pre>
<p>
You can even specifify a different directory for storing the temporary
files if you should need to, just pass a <tt>:tmp_dir</tt> key to
upload_column. There usually should&#8217;t be a need for this.
</p>
<h2>Manipulating image with RMagick</h2>
<p>
Say you would want (for whatever reason) to have a funky solarize effect on
your users&#8217; images. Manipulating images with upload_column can be
done either at runtime or after the image is saved, let&#8217;s look at
some possibilities:
</p>
<pre>
    class User &lt; ActiveRecord::Base
      upload_column :picture

      def picture_after_assign
        picture.process! do |img|
          img.solarize
        end
      end
    end
</pre>
<p>
Or maybe we want different versions of our image, then we could simply
specify:
</p>
<pre>
    class User &lt; ActiveRecord::Base
      upload_column :picture, :versions =&gt; [ :solarized, :sepiatoned ]

      def picture_after_assign
        picture.solarized.process! do |img|
          img.solarize
        end
        picture.sepiatoned.process! do |img|
          img.sepiatone
        end
      end
    end
</pre>
<p>
Or maybe we just want the image in different sizes?
</p>
<pre>
    class User &lt; ActiveRecord::Base
      upload_column :picture, :versions =&gt; { :thumb =&gt; &quot;100x100&quot;, :large =&gt; &quot;200x300&quot; }

      def picture_after_assign
        picture.thumb.process! do |img|
          img.solarize
        end
      end

    end
</pre>
<h2>Runtime rendering</h2>
<p>
You can manipulate images at runtime (it&#8217;s a huge performance hit
though!). In your controller add an action and use <a
href="../classes/UploadColumnRenderHelper.html#M000028">UploadColumnRenderHelper.render_image</a>.
</p>
<pre>
    def sepiatone
      @user = User.find(parms[:id])
      render_image @user.picture do |img|
        img.sepiatone
      end
    end
</pre>
<p>
And that&#8217;s it!
</p>
<p>
In your view, you can use <a
href="../classes/UploadColumnHelper.html#M000027">UploadColumnHelper.image</a>
to easily create an image tag for your action:
</p>
<pre>
    &lt;%= image :action =&gt; &quot;sepiatone&quot;, :id =&gt; 5 %&gt;
</pre>
<h2>Views</h2>
<p>
If your uploaded file is an image you would most likely want to display it
in your view, if it&#8217;s another kind of file you&#8217;ll want to link
to it. Both of these are easy using UploadColumn::BaseUploadedFile.url.
</p>
<pre>
    &lt;%= link_to &quot;Guitar Tablature&quot;, @song.tab.url %&gt;

    &lt;%= image_tag @user.picture.url %&gt;
</pre>
<h2>Validations</h2>
<p>
You can use SOME of Rails validations with <a
href="../classes/UploadColumn.html">UploadColumn</a>
</p>
<p>
validates_presence_of and validates_size_of have been verified to work.
</p>
<pre>
    validates_size_of :image, :maximum =&gt; 200000, :message =&gt; &quot;is too big, must be smaller than 200kB!&quot;
</pre>
<p>
Remember to change the error message, the default one sounds a bit stupid
with <a href="../classes/UploadColumn.html">UploadColumn</a>.
</p>
<p>
validates_uniqueness_of does NOT work, this is because
validates_uniqueness_of will send(:your_upload_column) instead of asking
for the instance variable, thus it will get an UploadedFile object, which
it can&#8217;t really compare to other values in the database, this is
rather difficult to work around without messing with Rails internals (if
you manage, please let me know!). Meanwhile you could do
</p>
<pre>
    validates_each :your_upload_column do |record, attr, value|
      record.errors.add attr, 'already exists!' if YourModel.find( :first, :conditions =&gt; [&quot;#{attr.to_s} = ?&quot;, value ] )
    end
</pre>
<p>
It&#8217;s not elegant I know, but it should work.
</p>

    </div>


   </div>


  </div>


    <!-- if includes -->

    <div id="section">





      


    <!-- if method_list -->


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>